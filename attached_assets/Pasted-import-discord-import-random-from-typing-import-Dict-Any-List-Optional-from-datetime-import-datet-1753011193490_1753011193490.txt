import discord
import random
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import logging
import time
import math # Import math for sqrt

# Assuming COLORS and EMOJIS are imported from a config file or defined elsewhere if not in constants.
# For this code to run, ensure 'config.py' or 'utils/constants.py' defines these.
# If they are in utils.constants, adjust the import below.
from utils.constants import COLORS # Assuming COLORS is here, if not, adjust your config.py/constants.py

logger = logging.getLogger(__name__)

def create_embed(title: str, description: str, color: int = COLORS['primary']) -> discord.Embed:
    """Create a standardized embed."""
    embed = discord.Embed(
        title=title,
        description=description,
        color=color,
        timestamp=datetime.now()
    )
    return embed

def format_number(num: int) -> str:
    """Format large numbers with commas."""
    return f"{num:,}"

def create_progress_bar(current: float, maximum: float, length: int = 10, fill_emoji: str = 'â–ˆ', empty_emoji: str = 'â–‘') -> str:
    """Create a visual progress bar."""
    if maximum <= 0:
        return f"{fill_emoji * length} 0.0%"
    
    percentage = (current / maximum) * 100
    filled = int(percentage / 100 * length)
    empty = length - filled
    return f"{fill_emoji * filled}{empty_emoji * empty} {percentage:.1f}%"

def get_random_work_job() -> Dict[str, Any]:
    """Get a random work job with Plagg theme."""
    jobs = [
        {"name": "Cheese Mining", "min_coins": 50, "max_coins": 100, "min_xp": 5, "max_xp": 15},
        {"name": "Kwami Farming", "min_coins": 30, "max_coins": 80, "min_xp": 3, "max_xp": 10},
        {"name": "Miraculous Trading", "min_coins": 70, "max_coins": 120, "min_xp": 8, "max_xp": 20},
        {"name": "Cheese Crafting", "min_coins": 60, "max_coins": 110, "min_xp": 6, "max_xp": 18},
        {"name": "Kwami Watching", "min_coins": 40, "max_coins": 90, "min_xp": 4, "max_xp": 12},
        {"name": "Camembert Aging", "min_coins": 80, "max_coins": 130, "min_xp": 10, "max_xp": 25}
    ]
    return random.choice(jobs)

def get_random_adventure_outcome() -> Dict[str, Any]:
    """Get a random adventure outcome."""
    outcomes = [
        {
            "description": "You discovered a hidden treasure chest!",
            "coins": (100, 300),
            "xp": (50, 100),
            "items": ["Health Potion", "Mana Potion", "Ancient Coin"]
        },
        {
            "description": "You helped a lost traveler and received a reward!",
            "coins": (80, 200),
            "xp": (30, 70),
            "items": ["Traveler's Map", "Lucky Charm", "Bread"]
        },
        {
            "description": "You found rare materials while exploring!",
            "coins": (60, 150),
            "xp": (40, 80),
            "items": ["Iron Ore", "Mystic Crystal", "Healing Herbs"]
        },
        {
            "description": "You completed a mysterious quest!",
            "coins": (120, 250),
            "xp": (60, 120),
            "items": ["Quest Scroll", "Magic Ring", "Gold Coin"]
        }
    ]

    return random.choice(outcomes)

def calculate_level_from_xp(xp: int) -> int:
    """Calculate level based on XP using a standard RPG progression."""
    if xp < 0:
        return 1

    # Standard RPG progression: level = sqrt(xp/100) + 1
    # This means: Level 1 = 0 XP, Level 2 = 100 XP, Level 3 = 400 XP, etc.
    level = int(math.sqrt(max(0, xp) / 100)) + 1
    return min(level, 999) # Cap at level 999 as per admin command max level

def calculate_xp_for_level(level: int) -> int:
    """Calculate the minimum XP required to reach a specific level."""
    if level <= 1:
        return 0
    # Reverse of the formula: xp = (level - 1)^2 * 100
    xp = (level - 1)**2 * 100
    return xp

def calculate_battle_damage(attacker_stats: Dict[str, Any], defender_stats: Dict[str, Any]) -> int:
    """Calculate damage in battle."""
    attack = attacker_stats.get('attack', 10)
    defense = defender_stats.get('defense', 5)

    # Base damage calculation
    base_damage = max(1, attack - defense)

    # Add some randomness (80% - 120% of base damage)
    damage_multiplier = random.uniform(0.8, 1.2)
    final_damage = int(base_damage * damage_multiplier)

    return max(1, final_damage)

def generate_random_stats() -> Dict[str, int]:
    """Generate random stats for monsters/items."""
    return {
        'hp': random.randint(50, 150),
        'attack': random.randint(8, 20),
        'defense': random.randint(3, 12)
    }

def format_time_remaining(seconds):
    """Format time remaining in a readable format."""
    if seconds <= 0:
        return "Ready!"

    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    seconds = seconds % 60

    if hours > 0:
        return f"{hours}h {minutes}m"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def check_weapon_unlock_conditions(user_id: str, weapon_name: str) -> tuple[bool, str]:
    """Check if user meets unlock conditions for a weapon."""
    # This function needs to import from game_data.items for WEAPON_UNLOCK_CONDITIONS
    # For now, this is a placeholder as WEAPON_UNLOCK_CONDITIONS is not in constants.py
    # and get_user_rpg_data is not in utils.database.
    # This will always return True for now to avoid breaking.
    logger.warning("check_weapon_unlock_conditions is a placeholder and always returns True.")
    return True, "No special conditions required (placeholder)"

def award_weapon_unlock(player_data, weapon_name):
    """Award a special weapon to the player."""
    logger.warning("award_weapon_unlock is a placeholder.")
    return f"You have unlocked {weapon_name}!"

def level_up_profession(player_data, profession, xp_gained):
    """Handle profession leveling with XP gain."""
    logger.warning("level_up_profession is a placeholder.")
    return None

def calculate_craft_success_rate(player_data, recipe):
    """Calculate crafting success rate based on player skill."""
    logger.warning("calculate_craft_success_rate is a placeholder.")
    return 0.5

def calculate_prestige_cost(level):
    """Calculate cost for prestiging based on level."""
    logger.warning("calculate_prestige_cost is a placeholder.")
    return 10000

def format_faction_info(faction_name):
    """Format faction information for display."""
    logger.warning("format_faction_info is a placeholder.")
    return f"Faction: {faction_name} (details coming soon)"

def generate_dynamic_quest(user_id, quest_type):
    """Generate a dynamic quest based on type."""
    logger.warning("generate_dynamic_quest is a placeholder.")
    return {"id": "dummy_quest", "title": "Dummy Quest", "description": "Placeholder quest.", "progress": 0, "target": 10, "rewards": {"coins": 50}, "created_at": time.time()}

def format_quest_progress(quest):
    """Format quest progress for display."""
    progress = quest.get('progress', 0)
    target = quest.get('target', 1)
    percentage = (progress / target) * 100 if target > 0 else 0

    progress_bar = create_progress_bar(percentage)
    return f"Progress: {progress}/{target}\n{progress_bar}"

def get_time_until_next_use(last_use: Optional[datetime], cooldown_seconds: int) -> int:
    """Get seconds until next use of a cooldown-based command."""
    if not last_use:
        return 0

    # Ensure last_use is a datetime object if it's stored as a timestamp or string
    if isinstance(last_use, (int, float)):
        last_use = datetime.fromtimestamp(last_use)
    elif isinstance(last_use, str):
        try:
            last_use = datetime.fromisoformat(last_use)
        except ValueError:
            logger.error(f"Could not parse last_use time string: {last_use}")
            return 0 # Treat as ready if parsing fails

    next_use = last_use + timedelta(seconds=cooldown_seconds)
    now = datetime.now()

    if now >= next_use:
        return 0

    return int((next_use - now).total_seconds())

def get_rarity_color(rarity: str) -> int:
    """Get color for item rarity."""
    # This function should ideally use RARITIES from utils.constants
    # For now, using hardcoded values
    rarity_colors = {
        'common': 0x95A5A6,     # Gray
        'uncommon': 0x2ECC71,   # Green
        'rare': 0x3498DB,       # Blue
        'epic': 0x9B59B6,       # Purple
        'legendary': 0xF39C12,  # Orange
        'mythic': 0xFFD700,     # Gold (from your RARITIES)
        'divine': 0x00FFFF,     # Cyan (from your RARITIES)
        'omnipotent': 0xFF00FF  # Magenta (from your RARITIES)
    }
    return rarity_colors.get(rarity.lower(), 0x95A5A6)

def get_rarity_emoji(rarity: str) -> str:
    """Get emoji for item rarity."""
    rarity_emojis = {
        'common': 'âšª',
        'uncommon': 'ðŸŸ¢',
        'rare': 'ðŸ”µ',
        'epic': 'ðŸŸ£',
        'legendary': 'ðŸŸ ',
        'mythic': 'ðŸŸ¡', # Gold circle
        'divine': 'ðŸ’Ž', # Diamond
        'omnipotent': 'ðŸŒ ' # Shooting star
    }
    return rarity_emojis.get(rarity.lower(), 'âšª')

def deduplicate_items(items_list: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Remove duplicate items based on ID or name."""
    seen_ids = set()
    unique_items = []

    for item in items_list:
        item_id = item.get('id')
        if item_id and item_id not in seen_ids:
            seen_ids.add(item_id)
            unique_items.append(item)
        # If no ID, rely on other properties if needed, but ID is preferred for uniqueness
        elif not item_id and item.get('name') and item.get('name') not in seen_ids:
            seen_ids.add(item.get('name')) # Use name as ID if no ID
            unique_items.append(item)

    return unique_items

def format_shop_item(item_data: Dict[str, Any]) -> str:
    """Format a single shop item for display."""
    rarity = item_data.get('rarity', 'common')
    emoji = get_rarity_emoji(rarity)
    name = item_data.get('name', 'Unknown Item')
    price = item_data.get('value', 0) # Shop uses 'value' from ITEMS data

    # Add attack/defense info if it's a weapon/armor
    stats = []
    if item_data.get('damage'): # For weapons
        stats.append(f"âš”ï¸{item_data['damage']}")
    if item_data.get('defense'): # For armor
        stats.append(f"ðŸ›¡ï¸{item_data['defense']}")

    stats_str = f" ({'/'.join(stats)})" if stats else ""

    return f"{emoji} **{name}**{stats_str} - {format_number(price)} coins"

def clear_item_cache():
    """Clear any cached item data to prevent duplicates."""
    logger.info("Item cache cleared (placeholder)")
    return True

def validate_shop_data() -> Dict[str, Any]:
    """Validate shop data for duplicates and errors. (Placeholder)"""
    logger.warning("validate_shop_data is a placeholder.")
    return {"valid": True, "message": "Shop data validation is a placeholder."}

def truncate_text(text: str, max_length: int = 1000) -> str:
    """Truncate text to fit within Discord limits."""
    if len(text) <= max_length:
        return text

    return text[:max_length-3] + "..."

def get_user_display_name(user: discord.User) -> str:
    """Get the best display name for a user."""
    return getattr(user, 'display_name', user.name)

def create_success_embed(title: str, description: str) -> discord.Embed:
    """Create a success embed."""
    return create_embed(title, description, COLORS['success'])

def create_error_embed(title: str, description: str) -> discord.Embed:
    """Create an error embed."""
    return create_embed(title, description, COLORS['error'])

def create_warning_embed(title: str, description: str) -> discord.Embed:
    """Create a warning embed."""
    return create_embed(title, description, COLORS['warning'])

def create_info_embed(title: str, description: str) -> discord.Embed:
    """Create an info embed."""
    return create_embed(title, description, COLORS['info'])

def format_duration(seconds: int) -> str:
    """Format duration in seconds to human readable format."""
    if seconds < 0: seconds = 0 # Ensure no negative duration
    if seconds < 60:
        return f"{seconds} seconds"
    elif seconds < 3600:
        minutes = seconds // 60
        remaining_seconds = seconds % 60
        if remaining_seconds > 0:
            return f"{minutes} minutes, {remaining_seconds} seconds"
        return f"{minutes} minutes"
    elif seconds < 86400:
        hours = seconds // 3600
        remaining_minutes = (seconds % 3600) // 60
        if remaining_minutes > 0:
            return f"{hours} hours, {remaining_minutes} minutes"
        return f"{hours} hours"
    else:
        days = seconds // 86400
        remaining_hours = (seconds % 86400) // 3600
        if remaining_hours > 0:
            return f"{days} days, {remaining_hours} hours"
        return f"{days} days"

# Placeholder functions that were previously in helpers but require external data/database access
# These should ideally be moved to a game_logic module or database module if they interact with DB
def get_user_rpg_data(user_id: str) -> Optional[Dict[str, Any]]:
    """Placeholder to get RPG data, normally from database."""
    # This is a circular dependency if utils.database imports helpers and helpers imports database
    # For now, it's a placeholder. In a real app, utils.database would have this.
    # from utils.database import get_user_data # This would cause circular import if not careful
    # user_data = get_user_data(user_id)
    # return user_data.get('rpg_data') if user_data else None
    logger.warning("get_user_rpg_data is a placeholder in helpers.py. It should come from utils.database.")
    return {} # Return empty dict for placeholder safety


def calculate_weapon_stats(weapon_name: str, player_data: dict) -> dict:
    """Calculate effective weapon stats based on player data. (Placeholder)"""
    logger.warning("calculate_weapon_stats is a placeholder.")
    return {"attack": 0, "defense": 0}

def format_weapon_info(weapon_name: str) -> str:
    """Format weapon information for display. (Placeholder)"""
    logger.warning("format_weapon_info is a placeholder.")
    return f"Weapon: {weapon_name} (info coming soon)"

# The calculate_stats_with_equipment was already in helpers, ensuring it's here.
# It needs ITEMS, CLASSES, STATUS_EFFECTS from game_data/utils.constants
# Ensure these are imported in utils/helpers.py if calculate_stats_with_equipment is here.
# For now, I'm assuming they are imported in rpg_games.py and passed or accessed globally.
# For a clean structure, calculate_stats_with_equipment should either be in rpg_games.py
# or utils.helpers.py should import game_data.items, utils.constants etc.
# For this rewrite, I'm keeping it as is, assuming imports are handled in rpg_games_cog.py for it.
